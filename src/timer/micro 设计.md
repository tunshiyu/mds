<!--
 * @文件描述:
 * @公司: thundersdata
 * @作者: 于效仟
 * @Date: 2022-05-18 10:28:02
 * @LastEditors: 于效仟
 * @LastEditTime: 2022-05-18 10:28:03
-->

一、业务背景

最近在做客户中心化项目，包含了客户池、客户呼叫、下派、档案管理及服务回流等操作。因为目前进行多支业务线的客户中心化开发，各个业务线的项目是分开独立的，各个业务线又都提出了客户中心化能力的需求。所以抽取了一套可配置的客户中心化业务模板作为子应用，服务于各业务的客户中心化。
基于以上业务背景触发了本文的思考和总结，文章比较长，期待和感谢您的阅读。

微前端需要的特征之一 “你的系统需要有一套支持动态插拔的机制”
--《你可能并不需要微前端》

二、技术背景

1、 子应用
微前端方案使用 Ihome 前端团队的 atom 微前端体系方案。主应用是老项目各自独立并已应用于 atom 微前端体系。
2、 配置化方案
配置化方案是在配置后台通过 json 配置一套业务模板，业务模板的表单方案借助于 formily 的能力。

三、 子应用

首先说下基础逻辑，客户中心化的功能相对独立且可复用，所以我们可以把它抽取出来作为子应用，挂到多个主应用上。并且主应用是一年前的项目，我们在进行当前中心化业务的开发时完全不用关心以前的代码是怎么写的，一些方案也可以在一个完全新的应用内开始，避免不同的思想耦合在一个应用内。这里引用磐冲师兄的一句话："当我们深入业务场景，不是只停留在框架的时候，我们发现微前端可以做到更多。回头来看，它也应该做到更多。"
那么具体实施简单记叙如下。

1、 创建子应用并关联主应用

在 atom 微前端研发平台的子应用创建页面新建。

这里的子应用类型可以选择 普通子应用/runtime,这里正常抽的带有路由的应用选择普通子应用,组件级的或者一个页面中的一个模块可以选择 runtime。basename 就是基准路由。
由于当前业务是客户中心化，所以后文的子应用的 basename 以/centerCustomer 叙述。通过它的指定保证所有的路由定义在 /centerCustomer 下，那么跳转到 /centerCustomer 路由时我们就可以加载渲染 /centerCustomer 对应的子应用 bundle 。
填好后关联到之前提到的不同业务对应的主应用。

2、 完成迭代并部署到多个业务

每个主应用对应一份自己的子应用版本配置。比如 centerCustomer 当前开发的版本为 0.0.1。那么各个主应用把 centerCustomer 更新到 0.0.1。发布这份配置也就是部署后。便可以通过 /主应用 basename/子应用 basename/子应用 routerPathName 查看

3、 怎么知道自己在哪个主应用

● 最挫的就是 url 直接判断，其实也可以。
● 通过主应用的配置传参，如下，子应用 optimus 在 app.tsx 的 props 中能拿到 biz 的值为 center。

● 通过登录态

四、 配置化方案及流程

接上文的我们已经抽为子应用，但是在不同业务中，还是有一些独有的逻辑。
以下我们以三种模拟的业务称号 buA/buB/buC 进行后文的叙述。
buA 业务的客户跟进状态有(未沟通/待跟进/服务中/已下派)四个状态，buA 业务的客户跟进状态有(待跟进/服务中/已下派)三个状态。如果是只有这一个差别 ifesle 来的更简单些，但是当这种情况是不可控且自定义的时候，配置化方案就来了。

1、 如何配置筛选项 filter/列表 column

首先在配置前有个字段池，这个就是前后端针对页面约定好的字段。配置核心就是通过 json 配置出一个 UI 组件并且选择在 n 个业务中的字段。
注意，这里不是不同业务选字段配 UI 组件。之所以这么设计是因为当通过 UI 页面去配置的时候，字段和 UI 之间没什么关联，但其实你是通过看到它是什么样子的表单才会去配置的。
举个例子，比如三个业务的筛选项看到一个名字输入框，你通过看到它是输入框会一起去配置。那么写一个如下 json，然后会有三个业务对应的这个字段的下拉，如果都选 customerName。那么每个业务的名字的 dataIndex 都是 customerName，如果 buC 没有选字段，则姓名不在 buC 展示。所以这是一个配组件选不同业务的字段的配置过程。

{ dataIndex: "customerName", title: "姓名", },

保存后，便完成了从 UI 到配置的过程。下面是从配置到应用层渲染的过程。应用层分为列表页和详情页。

2、 列表页拆分

UI 上拆分为筛选项 filter/列表 column/功能按钮，抽象一下就是一份表单 json 来渲染筛选项，一份 render 自定义组件的 columns 来渲染列表。列表页功能按钮目前业务上已经拉通，所以暂时不需要设计。
这里使用了 formily 1.x 的 useFormTableQuery API 处理查询列表。整体逻辑如下，通过服务端接口拿到 filters 和 columns。filters 给 formily 的消费。columns 经过处理给到 Table 组件。
这里简单提两点，具体的方案会放到下一期叙述。

● 对于自定义组件，比如筛选项里有 formily 无法 cover 的表单。通过在 json 里指定一个 renderComp 属性。如"renderComp":"ActivityIdFilterComp"。然后把 ActivityIdFilterComp 这个组件传到 schemaform 的 components 里补充他的表单项。列表需要自定义的同理。
● 对于筛选中如下拉的枚举，列表中通过枚举映射 label 的，通过传 enumType 字段。这里形成了一个流程，首先需要和服务端同学约定一个字典接口，传参的枚举就是 enumType 的值。然后我们通过一个 hooks 比如 useDim，在传了 enumType 的时候进行逻辑关联。这个是开发过程中形成的一个习惯流程，用起来还是比较爽的。

3、 详情页

这里有一些业务的思考。到了什么程度的页面适合去业务配置？
首先我觉得做技术向拉通这件事，没有产品的拉通和认可的收益是很小的，好像为了做复用而做一样。在我看来，模块可做复用的最低条件为：不同情况下，模块的主流程的 UI 逻辑是一致的。
这里介绍一下背景。之前 ABC 业务的产品是独立没有一起过需求的，所以他们设计的产品形态有很大的差异，UI 逻辑是完全不同的。所以目前详情页是没有进行配置化的设计的，而是提供了不同详情组件进行跳转。
只配个列表页这有用吗，有点用，但好像又没什么大用，那怎么办呢？这里结合一句话来讲："做业务要有 owner 精神，要有主人翁意识"。一家业务公司，技术提效是结合着业务说量化的，如果脱离了业务搞技术建设和耍流氓有什么区别。所以，当发现了能拉通的技术点，产品却存在问题时，沟通便有了作用。当时沟通分两个方面展开，第一是主流程能不能统一做兼容，能的话谁向谁兼容，第二是业务上不愿意动，那句金句"能运行的就别动"背后有很多原因。
这里感谢一下我的师兄作为业务"话事人"帮助我拉通了业务上人和事的事情。目前 buABC 的详情页的主流程已经趋向统一，后面也会通过配置化做起来。

五、 结果

目前通过这套配置化能力及微前端能力，技术上基本实现了一个功能模块可以服务于多个业务，业务上有效促进了产品设计上具有一定的规范和通用性。路漫漫其修远兮。

六、 思考

1、子应用的子应用产生的依赖关系

比如/centerCustomer 作为子应用，还有一个子应用/centerCustomerxxx。这个时候主应用需要先关联 centerCustomer，然后再关联 centerCustomerxxx，如果是多个主应用用 centerCustomer，那这个维护成本就增高了。所以这里是否可以通过依赖关系简化流程，甚至子应用部署的时候根据当前版本号找到多个主应用一起发布，我后面会和团队同学一起聊一下。

2、 判断的逻辑通过策略模式重构

目前代码里还是有部分 ifelse 逻辑，通过策略模式会有多大的收益，后面会尝试一下。

3、 做技术建设文档先行

在做配置化的时候没有提前进行链路疏通和文档设计，而是直接在代码层进行了抽取和尝试。不过我的师兄进行了及时地劝导，很巧的是当时正好读到《开源给我带来了什么》里面提到。

高效工作里面包括几个小点，首先是文档优先。

有的时候，书里写的话，长辈说的话在没实践前光听是没有体量的，当你真正走了一遍踩了一遍坑，回头再看他们写的那些总结和文档。你会拍案惊呼：我 x，原来是这样啊。

七、 参考资料

● 你可能并不需要微前端
● 微前端能给前端应用带来什么
● 开源有带给我什么
● 面向大型工作台的微前端解决方案 icestark
● formily 快速开始
